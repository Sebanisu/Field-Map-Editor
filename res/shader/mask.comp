#version 430 core

precision highp float;
precision highp int;

// Input textures
layout(binding = 0, rgba8) uniform image2D maskTexture;
layout(binding = 1, rgba8) uniform image2D imageTexture;

// Output texture
layout(binding = 2, rgba8) uniform image2D outputTexture;

// Palette buffer
layout(binding = 3, std430) buffer PaletteBuffer {
    vec4 palette[];
};

// Uniforms
uniform int chosenIndex;
uniform int numColors;
uniform float blackTolerance = 0.01;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputSize = imageSize(outputTexture);

    if (pixelCoord.x >= outputSize.x || pixelCoord.y >= outputSize.y) {
        return;
    }

    vec4 maskColor = imageLoad(maskTexture, pixelCoord);
    vec4 imageColor = imageLoad(imageTexture, pixelCoord);
        //imageStore(outputTexture, pixelCoord, imageColor);
        //return;

    // Early out if mask is black
    if (distance(maskColor.rgb, vec3(0.0)) < blackTolerance) {
        imageStore(outputTexture, pixelCoord, vec4(0.0));
        return;
    }

    // Find closest palette color to maskColor
    int bestIndex = 0;
    float bestDist = 1e20;

    for (int i = 0; i < numColors; i++) {
        vec4 d = maskColor - palette[i];
        float dist = dot(d, d);
        if (dist < bestDist) {
            bestDist = dist;
            bestIndex = i;
        }
    }

    // Only draw if it matched the chosen index
    if (bestIndex == chosenIndex) {
        imageStore(outputTexture, pixelCoord, imageColor);
    } else {
        imageStore(outputTexture, pixelCoord, vec4(0.0));
    }
}